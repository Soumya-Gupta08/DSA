
                // RowColumnOrderedMatrix search //
                // to search in rowcoulumnorderedmatrix

    public static int[] rowColumnOrderedBinarySearch(int[][] mat, int target) {
        int row=0;
        int col=mat[0].length-1;

        while(row<mat.length && col>=0) {
            int elem=mat[row][col];
            if(elem==target) {
                return new int[] {row, col};
            } else if(elem<target) {
                row++;
            } else {
                col--;
            }
        }
        return new int[] {-1, -1};
    }

                    // OrderedMatrix search //
                    // to search in orderedmatrix

    public static int[] matrixOrderedBinarySearch(int[][] mat, int target) {
        if(mat.length==1) {
            rowBinarySearch(mat, target, 0, 0, mat[0].length-1);
        }
        int cMid=(mat[0].length-1)/2;

        int rStart=0;
        int rEnd=mat.length-1;

        // Run loop until just two rows are left to check
        while(rStart+1<rEnd) {
            int rMid=rStart+(rEnd-rStart)/2;

            if(mat[rMid][cMid]==target) {
                return new int[] {rMid, cMid};
            } else if(mat[rMid][cMid]>target) {
                rEnd=rMid;
            } else {
                rStart=rMid;
            }
        }

        // Now we have 2 rows remaining to check
        // So, check in the cMid if the two elements are the target or not
        if(mat[rStart][cMid]==target) {
            return new int[] {rStart, cMid};
        } else if(mat[rStart+1][cMid]==target) {
            return new int[] {rStart+1, cMid};
        }

        // Now, divide the rest into four parts and check
        if(mat[rStart][cMid]>target) {
            return rowBinarySearch(mat, target, rStart, 0, cMid-1);
        } else if(mat[rStart][cMid]<target && mat[rStart][mat[0].length-1]>=target) {
            return rowBinarySearch(mat, target, rStart, cMid+1, mat[0].length-1);
        } else if(mat[rStart+1][cMid]>target) {
            return rowBinarySearch(mat, target, rStart+1, 0, cMid-1);
        } else {
            return rowBinarySearch(mat, target, rStart+1, cMid+1, mat[0].length-1);
        }
    }

    // to search in the provided row
    public static int[] rowBinarySearch(int[][] mat, int target, int row, int cStart, int cEnd) {
        while(cStart<=cEnd) {
            int cMid=cStart+(cEnd-cStart)/2;
            if(mat[row][cMid]==target) {
                return new int[] {row, cMid};
            } else if(mat[row][cMid]<target) {
                cStart=cMid+1;
            } else {
                cEnd=cMid-1;
            }
        }
        return new int[] {-1, -1};
    }
